var documenterSearchIndex = {"docs":
[{"location":"#SVDD.jl-1","page":"Home","title":"SVDD.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Documentation for SVDD.jl","category":"page"},{"location":"start/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"start/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"start/#","page":"Getting Started","title":"Getting Started","text":"SVDD.jl is not yet registered. To install, run","category":"page"},{"location":"start/#","page":"Getting Started","title":"Getting Started","text":"(v1.0) pkg> add https://github.com/englhardt/SVDD.jl","category":"page"},{"location":"smo/#SMO-1","page":"SMO","title":"SMO","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"Sequential Minimal Optimization (SMO) is a decomposition method to solve quadratic optimization problems with a specific structure. The original SMO algorithm by John C. Platt has been proposed for Support Vector Machines (SVM). There are several modifications for other types of support vector machines. This section describes the implementation of SMO for Support Vector Data Description (SVDD) [2].","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The implementation of SMO for SVDD bases on an adaption of SMO for one-class classification [3]. Therefore, this documentation focuses on the specific adaptions required for SVDD. The following descriptions assume familarity with the basics of SMO [1] and its adaption to one-class SVM [3], and of SVDD [2].","category":"page"},{"location":"smo/#SVDD-Overview-1","page":"SMO","title":"SVDD Overview","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"SVDD is an optimization problem of the following form.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  beginaligned\n  P   undersetR a xitextminimize\n    R^2 + sum_i xi_i  \n   textsubject to\n    leftVert Phi(x_i) - a rightVert^2 leq R^2 + xi_i   i \n     xi_i geq 0   i\n  endaligned","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"with radius R and center of the hypershpere a, a slack variable xi, and a mapping into an implicit feature space Phi","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The Lagrangian Dual is:","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"beginaligned\nD   undersetalphatextmaximize\n  sum_ijalpha_ialpha_j K_ij + sum_i alpha_iK_ii  \n textsubject to\n  sum_i alpha_i = 1 \n   0 leq alpha_i leq C   i \nendaligned","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"where alpha are the Lagrange multipliers, and K_ij = langle Phi(x_i)Phix_j rangle the inner product in the implicit feature space. Solving the Lagrangian gives an optimal α.","category":"page"},{"location":"smo/#SMO-for-SVDD-1","page":"SMO","title":"SMO for SVDD","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The basic idea of SMO is to solve reduced versions of the Lagrangian iteratively. In each iteration, the reduced version of the Lagrangian consists of only two decision variables, i.e., alpha_i1 and alpha_i2, while alpha_j ji1 i2 are fixed. An iteration of SMO consists of two steps:","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"Selection Step: Select i1 and i2.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The search for a good i2 are implemented in SVDD.smo\nThere are several heuristics to select i1 based on the choice for i2. These heuristics are implemented in SVDD.examineExample!","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"Optimization Step: Solving the reduced Lagrangian for alpha_i1 and alpha_i2.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"Implemented in SVDD.takeStep!","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The iterative procedure converges to the global optimum. The following sections give details on both steps.","category":"page"},{"location":"smo/#Optimization-Step:-Solving-the-reduced-Lagrangian-1","page":"SMO","title":"Optimization Step: Solving the reduced Lagrangian","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The following describes how to infer the optimal solution for a given alpha_i1 and alpha_i2 analytically.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"First, alpha_i1 and alpha_i2 can only be changed in a limited range. The reason is that after the optimization step, they still have to obey the constraints of the Lagrangian. From sum_ialpha_i = 1, one can infer that Δ = alpha_i1 + alpha_i2 remains constant for one optimization step. This is, if we add some value to alpha_i2, we must remove the same value from alpha_i1. We also know that alpha_i geq 0 and alpha_i leq C. From this, one can infer the maximum and minumum value that one can add/substract from alpha_i2, i.e., one can calculate the lower and the upper bound:","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"beginaligned\n  L = max(0 alpha_i1 + alpha_i2 - C)\n  H = min(C alpha_i1 + alpha_i2)\nendaligned","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"(Note: This is slightly different to the original SMO, as one does not need to discern between different labels y_i in 1-1.)","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"Second, the optimal value alpha^*_i2 can be derived analytically by setting the partial derivative of the Lagrangian objective function to 0.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"f_D = sum_ij alpha_i alpha_j K_ij - sum_ialpha_i K_ii \nfracdelta f_Dalpha_i2 = 0\n\niff  alpha^*_i2 = frac2Delta(K_i1i1 - K_i1i2) + C_1 - C_2 - K_i1i1 + K_i2i22K_i1i1+2K_i2 i2-4K_i1 i2 \ntextwhere  C_k=alpha_ksum_j=3^Nalpha_j K_kj","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The resulting value is clipped to the feasible interval.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"if α*_i2 > H\n    α'_i2 = H\nelseif α*_i2 < L\n    α'_i2 = L\nend","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"where α'_i2 is the updated value of α_i2 after the optimization step. It follows that","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  α'_i1 = Δ - α'_i2","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"To allow the algorithm to converge, one has to decide on a threshold whether the updates to the alpha values has been significant, i.e., if the difference between the old and the new value is above a specified precision. The implementation uses the decision rule from the original SMO [1, p.10], i.e., update alpha values only if","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"lvertalpha_i2 - alpha_i2 rvert  textopt_precision * (alpha_i2 + alpha_i2 + textopt_precision)","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"where opt_precision is a parameter of the optimization algorithm. This optimization step is implemented in","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"SVDD.takeStep!","category":"page"},{"location":"smo/#SVDD.takeStep!","page":"SMO","title":"SVDD.takeStep!","text":"takeStep!(α, i1, i2, K, C, opt_precision)\n\nTake optimization step for i1 and i2 and update α.\n\n\n\n\n\n","category":"function"},{"location":"smo/#Selection-Step:-Finding-a-pair-(i1,-i2)-1","page":"SMO","title":"Selection Step: Finding a pair (i1, i2)","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"To take an optimization step, one has to select i1 and i2 first. The rationale of SMO is to select indices that are likely to make a large step optimization step. SMO uses heuristics to first select i2, and then select i1 based on it.","category":"page"},{"location":"smo/#Selection-of-i2-1","page":"SMO","title":"Selection of i2","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"A minimum of P has to obey the KKT conditions. The relevant KKT condition here is complementary slackness, i.e.,","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  mu_i g_i(x^*) = 0  forall i","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"with dual variable mu and inequality conditions g. In other words, either the inequality constraint is fulfilled with equality, i.e., g_i = 0, or the Lagrange multiplier is zero, i.e., mu_i=0. For SVDD, this translates to","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  beginaligned\n    leftlVert a - phi(x_i) rightrVert^2  R^2 rightarrow alpha_i = 0 \n    leftlVert a - phi(x_i) rightrVert^2 = R^2 rightarrow  0  alpha_i  C\n    leftlVert a - phi(x_i) rightrVert^2  R^2 rightarrow alpha_i = C\n endaligned","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"See [2] for details. The distance to the decision boundary is leftlVert a - phi(x_i) rightrVert^2 - R^2 which is negative for observations that lie in the hypershpere.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"So to check for KKT violations, one has to calculate the distance of phi(x_i) from the decision boundary, i.e., the left-hand side of the implications above, and compare it with the the respective alpha value. The check for KKT violations is implemented in","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.violates_KKT_condition","category":"page"},{"location":"smo/#SVDD.violates_KKT_condition","page":"SMO","title":"SVDD.violates_KKT_condition","text":"violates_KKT_condition(i2, distances_to_decision_boundary, α, C, opt_precision)\n\n\n\n\n\n","category":"function"},{"location":"smo/#","page":"SMO","title":"SMO","text":"SVDD.smo selects i2 by searching for indices that violate the KKT conditions.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.smo","category":"page"},{"location":"smo/#SVDD.smo","page":"SMO","title":"SVDD.smo","text":"smo(α, K, C, opt_precision, max_iterations)\n\n\n\n\n\n","category":"function"},{"location":"smo/#","page":"SMO","title":"SMO","text":"This function conducts two tyes of search.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"First type: search over the full data set, and randomly selects one of the violating indices.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"Second type: restricted search for violations over the subset where 0 alpha_i  C. These variables are the non-bounded support vectors SV_nb.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"There is one search of the first type, then multiple searches of the second type. After each search, i2 is selected randomly from one of the violating indices, see","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"SVDD.examine_and_update_predictions!","category":"page"},{"location":"smo/#SVDD.examine_and_update_predictions!","page":"SMO","title":"SVDD.examine_and_update_predictions!","text":"examine_and_update_predictions!(α, distances_to_center, distances_to_decision_boundary, R,\n    KKT_violations, black_list, K, C, opt_precision)\n\n\n\n\n\n","category":"function"},{"location":"smo/#Selection-of-i1-1","page":"SMO","title":"Selection of i1","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"SMO selects i1 such that the optimization step is as large as possible. The idea for selecting i1 is as follows. For alpha_i2  0 and negative distance to decision boundary, alpha may decrease. So a good alpha_i1 is one that is likely to increase in the optimization step, i.e., an index where the distance to the decision boundary is positive, and alpha_i1 = 0. The heuristic SMO selects the i1 with maximum absolute distance between the distance to the center of i2 and the distance to the center of some i1 in SV_nb. (Note that using the distance to the decision boundary is equivalent to using the distance to the center in this step). This selection heuristic is implemented in","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.second_choice_heuristic","category":"page"},{"location":"smo/#SVDD.second_choice_heuristic","page":"SMO","title":"SVDD.second_choice_heuristic","text":"second_choice_heuristic(i2, α, distances_to_center, C, opt_precision)\n\n\n\n\n\n","category":"function"},{"location":"smo/#","page":"SMO","title":"SMO","text":"In some cases, the selected i1 does not lead to a positive optimization step. In this case, there are two fallback strategies. First, all other indices in SV_nb are selected, in random order, whether they result in a positive optimization step. Second, if there still is no i1 that results in a positive optimization step, all remaining indices are selected. If none of the fallback strategies works, i2 is skipped and added to a blacklist. The fallback strategies are implemented in","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.examineExample!","category":"page"},{"location":"smo/#SVDD.examineExample!","page":"SMO","title":"SVDD.examineExample!","text":"examineExample!(α, i2, distances_to_center, K, C, opt_precision)\n\nThe fallback strategies if second choice heuristic returns false follow recommendations in\nJ. Platt, \"Sequential minimal optimization: A fast algorithm for training support vector machines,\" 1998.\n\n\n\n\n\n","category":"function"},{"location":"smo/#Termination-1","page":"SMO","title":"Termination","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"If there are no more KKT violations, the algorithm terminates.","category":"page"},{"location":"smo/#Further-implementation-details-1","page":"SMO","title":"Further implementation details","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"This section describes some further implementation details.","category":"page"},{"location":"smo/#Initialize-alpha-1","page":"SMO","title":"Initialize alpha","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The vector alpha must be initialized such that it fulfills the constraints of D. The implementation uses the initialization strategy proposed in [3], i.e., randomly setting frac1C indices to C. This is implemented in","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.initialize_alpha","category":"page"},{"location":"smo/#SVDD.initialize_alpha","page":"SMO","title":"SVDD.initialize_alpha","text":"initialize_alpha(data, C)\n\n\n\n\n\n","category":"function"},{"location":"smo/#Calculating-Distances-to-Decision-Boundary-1","page":"SMO","title":"Calculating Distances to Decision Boundary","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"The distances to the decision boundary are calculated in","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.calculate_predictions","category":"page"},{"location":"smo/#SVDD.calculate_predictions","page":"SMO","title":"SVDD.calculate_predictions","text":"calculate_predictions(α, K, C, opt_precision)\n\n\n\n\n\n","category":"function"},{"location":"smo/#","page":"SMO","title":"SMO","text":"In general, to calculate R, one can calculate the distance to any non-bounded support vector, i.e., 0  alpha_i  C, as they all lie on the hypershpere. However, this may not always hold. There may be cases where the solution for R is not unique, and different support vectors result in different R, in particular in intermediate optimization steps where some alpha values may be non-bounded but violate the KKT conditions. Therefore, R is averaged over all non-bounded support vectors. See also [4] for details on non-unique R values.","category":"page"},{"location":"smo/#SMO-parameters-1","page":"SMO","title":"SMO parameters","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"There are two parameters for SMO: opt_precision and max_iterations.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"opt_precision influences the convergence. Small opt_precision values require a larger number of iterations until termination.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"max_iterations controls the number of times a new i2 is selected to attempt an optimization step.","category":"page"},{"location":"smo/#External-API-1","page":"SMO","title":"External API","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"  SVDD.solve!(model::VanillaSVDD, solver::SMOSolver)","category":"page"},{"location":"smo/#SVDD.solve!-Tuple{VanillaSVDD,SMOSolver}","page":"SMO","title":"SVDD.solve!","text":"solve!(model::VanillaSVDD, solver::SMOSolver)\n\n\n\n\n\n","category":"method"},{"location":"smo/#References-1","page":"SMO","title":"References","text":"","category":"section"},{"location":"smo/#","page":"SMO","title":"SMO","text":"[1] J. Platt, \"Sequential minimal optimization: A fast algorithm for training support vector machines,\" 1998.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"[2] D. M. J. Tax and R. P. W. Duin, \"Support Vector Data Description,\"\" Mach. Learn., 2004.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"[3] B. Schölkopf, J. C. Platt, J. Shawe-Taylor, A. J. Smola, and R. C. Williamson, \"Estimating the support of a high-dimensional distribution,\"\" Neural Comput., 2001.","category":"page"},{"location":"smo/#","page":"SMO","title":"SMO","text":"[4] W.-C. Chang, C.-P. Lee, and C.-J. Lin, \"A revisit to support vector data description,\"Nat. Taiwan Univ., Tech. Rep, 2013.","category":"page"}]
}
